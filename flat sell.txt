// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

contract FlatSell {

  address admin;
  address owner1;

  struct Flat{
    uint square;
    uint term;
    bool own;
  } 

  struct Sell{
    address owner;
    uint flatId;
    uint price;
    uint prevPrice; 
    uint sellTerm;
    bool sellStatus; // активно ли объявление
    address buyer; // текущий покупатель
    address prevBuyer; // предыдущий покупатель, чью цену перебил 
    bool ownerConfirm; // какой ответ дан владельцем
  }

  mapping(address => Flat[]) flats;
  Sell[] sellRequests;

  constructor(){
    admin = msg.sender;
    owner1 = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;
    flats[owner1].push(Flat(50, block.timestamp, true));
  }


  function addFlat (address owner, uint square) public{
    require(msg.sender == admin, "You dont have permission");
    require(square != 0, "Flat square cant be 0");
    flats[owner].push(Flat(square, block.timestamp, true));
  }

  function addSellRequest(uint flatId, uint price) public{
    require(flats[msg.sender][flatId].own == true, "You no longer own this flat");
    require(flats[msg.sender].length > flatId, "Flat doesnt exist");
    require(price > 0, "Price must be greater than 0");
    sellRequests.push(Sell(msg.sender, flatId, price, 0, block.timestamp, false,  address(0), address(0), false));
  }

  function cancelSellRequest(uint requestId) public{
    require(sellRequests[requestId].owner == msg.sender, "Its not your request");
    require(sellRequests[requestId].sellStatus == false, "Request already completed");
    require(sellRequests[requestId].sellTerm + 60 >= block.timestamp, "Request already expired");
    sellRequests[requestId].sellStatus = true;
  }

  function buyRequest(uint flatId) public payable {
    require(msg.sender != sellRequests[flatId].owner, "You cant buy your flat");  
    require(sellRequests[flatId].sellStatus == false, "Flat already selled");
    require(sellRequests[flatId].sellTerm <= block.timestamp, "This request has expired");
    require(sellRequests[flatId].buyer == address(0), "That request already have a buyer");
    require(msg.value == sellRequests[flatId].price, "You dont have enough money");
    
    sellRequests[flatId].buyer = msg.sender;
  }

  function enterAuction (uint requestId, uint newPrice) public payable{
    require(msg.sender != sellRequests[requestId].owner, "You cant buy your flat");  
    require(sellRequests[requestId].sellStatus == false, "Flat already selled");
    require(sellRequests[requestId].sellTerm <= block.timestamp, "This request has expired");
    require(newPrice > sellRequests[requestId].price, "Enter a higher price than the current one");
    require(sellRequests[requestId].buyer != address(0), "That request doesnt yet have a buyer");
    require(sellRequests[requestId].buyer != msg.sender, "No one has beaten your price yet");
    require(msg.value == newPrice, "You dont have enough money");
    
    // payable(sellRequests[requestId].buyer).transfer(sellRequests[requestId].price);  деньги предыдущего будут храниться до того момента как его не перебьют 2 человека
    if (sellRequests[requestId].prevBuyer != address(0)){
      payable(sellRequests[requestId].prevBuyer).transfer(sellRequests[requestId].prevPrice); // 3 покупателю вернут деньги и он вообще выйдет из аукциона
    }
    sellRequests[requestId].prevBuyer = sellRequests[requestId].buyer;
    sellRequests[requestId].prevPrice = sellRequests[requestId].price;
    sellRequests[requestId].price = newPrice;
    sellRequests[requestId].buyer = msg.sender;
  }

  function ownerConfirm(uint requestId, bool confirmation) public{
    require(msg.sender == sellRequests[requestId].owner, "You dont own this flat");
    require(sellRequests[requestId].sellStatus == false, "Flat already selled");
    require(sellRequests[requestId].buyer != address(0), "That request dont have buyer");

    sellRequests[requestId].ownerConfirm = confirmation;

    if (sellRequests[requestId].sellTerm + 60 < block.timestamp || confirmation == false){
      payable(sellRequests[requestId].buyer).transfer(sellRequests[requestId].price); // если время действия объявления вышло и потом владелец соглашается, то сделка отмениться и деньги вернуться покупателю
      payable(sellRequests[requestId].prevBuyer).transfer(sellRequests[requestId].prevPrice); 
    }
    else{
        payable(sellRequests[requestId].owner).transfer(sellRequests[requestId].price);
        payable(sellRequests[requestId].prevBuyer).transfer(sellRequests[requestId].prevPrice); // возврат предыдущему покупателю
        address oldOwner = sellRequests[requestId].owner;
        address newOwner = sellRequests[requestId].buyer;
        uint square = flats[oldOwner][sellRequests[requestId].flatId].square;
        uint term =  flats[oldOwner][sellRequests[requestId].flatId].term;
        flats[newOwner].push(Flat(square, term, true));
        flats[sellRequests[requestId].owner][sellRequests[requestId].flatId].own = false;  
        sellRequests[requestId].sellStatus = true;
    }
  }

  function buyerCancel(uint requestId) public{
    require(sellRequests[requestId].buyer == msg.sender, "You not current buyer");
    require(sellRequests[requestId].sellStatus == false, "Flat already selled");

    payable(sellRequests[requestId].buyer).transfer(sellRequests[requestId].price);
    sellRequests[requestId].buyer = sellRequests[requestId].prevBuyer;
    sellRequests[requestId].price = sellRequests[requestId].prevPrice;

  }

  function prevBuyerCancel(uint requestId) public{
    require(sellRequests[requestId].prevBuyer == msg.sender, "You not previous buyer");
    require(sellRequests[requestId].sellStatus == false, "Flat already selled");

    payable(sellRequests[requestId].prevBuyer).transfer(sellRequests[requestId].prevPrice);
    sellRequests[requestId].prevBuyer = address(0);
  }

  function showFlats(address owner) public view returns(Flat[] memory){
    return flats[owner];
  }

  function showSellRequests() public view returns(Sell[] memory){
    return sellRequests;
  }

}

