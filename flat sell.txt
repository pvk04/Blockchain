// SPDX-License-Identifier: GPL-3.0

pragma solidity >=0.7.0 <0.9.0;

contract FlatSell {

  address admin;
  address owner1;

  struct Flat{
    uint square;
    uint term;
    bool own;
  } // Сделать зависимость от аренды и подарка?

  struct Sell{
    address owner;
    uint flatId;
    uint price;
    uint prevPrice; 
    uint sellTerm;
    bool sellStatus; // активно ли объявление
    address buyer; // текущий покупатель
    address prevBuyer; // предыдущий покупатель, чью цену перебил 
    bool ownerConfirm; // какой ответ дан владельцем
  }

  mapping(address => Flat[]) flats;
  Sell[] sellRequests;

  constructor(){
    admin = msg.sender;
    owner1 = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;
    flats[owner1].push(Flat(50, block.timestamp, true));
  }


  function addFlat (address owner, uint square, uint term) public{
    require(msg.sender == admin, "You dont have permission");
    require(square != 0, "Flat square cant be 0");
    flats[owner].push(Flat(square, term, true));
  }

  function addSellRequest(uint flatId, uint price) public{
    require(flats[msg.sender][flatId].own == true, "You no longer own this flat");
    require(flats[msg.sender].length > flatId, "Flat doesnt exist");
    require(price > 0, "Price must be greater than 0");
    // статус продажи
    sellRequests.push(Sell(msg.sender, flatId, price, price, block.timestamp, false,  address(0), address(0), false));
  }

  function cancelSellRequest(uint requestId) public{
    require(sellRequests[requestId].owner == msg.sender, "Its not your request");
    require(sellRequests[requestId].sellStatus == false, "Request already completed");
    require(sellRequests[requestId].sellTerm + 60 >= block.timestamp, "Request already expired");
    sellRequests[requestId].sellStatus = true;
  }

  function buyRequest(uint flatId) public payable {
    require(msg.sender != sellRequests[flatId].owner, "You cant buy your flat");  
    require(sellRequests[flatId].sellStatus == false, "Flat already selled");
    require(sellRequests[flatId].sellTerm <= block.timestamp, "This request has expired");
    require(sellRequests[flatId].buyer == address(0), "That request already have a buyer");
    require(msg.value == sellRequests[flatId].price, "You dont have enough money");
    
    sellRequests[flatId].buyer = msg.sender;
  }

  function enterAuction (uint requestId, uint newPrice) public payable{
    require(msg.sender != sellRequests[requestId].owner, "You cant buy your flat");  
    require(sellRequests[requestId].sellStatus == false, "Flat already selled");
    require(sellRequests[requestId].sellTerm <= block.timestamp, "This request has expired");
    require(newPrice > sellRequests[requestId].price, "Enter a higher price than the current one");
    require(sellRequests[requestId].buyer != address(0), "That request doesnt yet have a buyer");
    require(sellRequests[requestId].buyer != msg.sender, "No one has beaten your price yet");
    require(msg.value == newPrice, "You dont have enough money");
    
    // payable(sellRequests[requestId].buyer).transfer(sellRequests[requestId].price);  деньги предыдущего будут храниться до того момента как его не перебьют 2 человека
    if (sellRequests[requestId].prevBuyer != address(0)){
      payable(sellRequests[requestId].prevBuyer).transfer(sellRequests[requestId].prevPrice); // 3 покупателю вернут деньги и он вообще выйдет из аукциона
    }
    sellRequests[requestId].prevBuyer = sellRequests[requestId].buyer;
    sellRequests[requestId].prevPrice = sellRequests[requestId].price;
    sellRequests[requestId].price = newPrice;
    sellRequests[requestId].buyer = msg.sender;
  }

  function ownerConfirm(uint requestId, bool confirmation) public{
    require(msg.sender == sellRequests[requestId].owner, "You dont own this flat");
    require(sellRequests[requestId].sellStatus == false, "Flat already selled");
    require(sellRequests[requestId].buyer != address(0), "That request dont have buyer");

    sellRequests[requestId].ownerConfirm = confirmation;

    if (sellRequests[requestId].sellTerm + 60 < block.timestamp || confirmation == false){
      payable(sellRequests[requestId].buyer).transfer(sellRequests[requestId].price); // если время действия объявления вышло и потом владелец соглашается, то сделка отмениться и деньги вернуться покупателю
      payable(sellRequests[requestId].prevBuyer).transfer(sellRequests[requestId].prevPrice); 
    }
    else{
        payable(sellRequests[requestId].owner).transfer(sellRequests[requestId].price);
        payable(sellRequests[requestId].prevBuyer).transfer(sellRequests[requestId].prevPrice); // возврат предыдущему покупателю
        address oldOwner = sellRequests[requestId].owner;
        address newOwner = sellRequests[requestId].buyer;
        uint square = flats[oldOwner][sellRequests[requestId].flatId].square;
        uint term =  flats[oldOwner][sellRequests[requestId].flatId].term;
        flats[newOwner].push(Flat(square, term, true));
        flats[sellRequests[requestId].owner][sellRequests[requestId].flatId].own = false;  
        sellRequests[requestId].sellStatus = true;
    }
  }

  function buyerCancel(uint requestId) public{
    require(sellRequests[requestId].buyer == msg.sender, "You not current buyer");
    require(sellRequests[requestId].sellStatus == false, "Flat already selled");

    payable(sellRequests[requestId].buyer).transfer(sellRequests[requestId].price);
    sellRequests[requestId].buyer = sellRequests[requestId].prevBuyer;
    sellRequests[requestId].price = sellRequests[requestId].prevPrice;
    //нужны пустые адреса на предыдущего!
    sellRequests[requestId].prevBuyer = address(0);
  }

  function prevBuyerCancel(uint requestId) public{
    require(sellRequests[requestId].prevBuyer == msg.sender, "You not previous buyer");
    require(sellRequests[requestId].sellStatus == false, "Flat already selled");

    payable(sellRequests[requestId].prevBuyer).transfer(sellRequests[requestId].prevPrice);
    sellRequests[requestId].prevBuyer = address(0);
  }

  function showFlats(address owner) public view returns(Flat[] memory){
    return flats[owner];
  }

  function showSellRequests() public view returns(Sell[] memory){
    return sellRequests;
  }

}


contract FlatArenda is FlatSell{
    struct flatArendaRequest{
        address owner;
        uint flatId;
        uint price;
        uint term;
        address renter; //Арендатор
        bool arendaStatus; //Активно ли объявление
        bool status; //Снимает ли кто-то квартиру. Нужен ли аукцион? Если нет, то можно удалить переменную
        uint startArenda; //Временная метка, с начала съема квартиры арендатором
        // Сделать в функции запроса на аренду или отдельной ф. условие: если у пред. владельца закончился срок аренды, то квартиру опять можно снять
        // либо нужно каждый раз добавлять новое объявление, если нужна история аренды
    }

    flatArendaRequest[] arendaRequests;

    function addArendaRequest(uint flatId, uint price, uint term) public{
        require(FlatSell.flats[msg.sender].length > flatId, "Flat doesn't exist");
        require(FlatSell.flats[msg.sender][flatId].own == true, "You are no longer the owner");
        require(price > 0, "Price must be greater than 0");
        require(term > 0, "Term must be greater than 0");

        arendaRequests.push(flatArendaRequest(msg.sender, flatId, price, term, address(0), true, false, 0));
    }
    
    function cancelArendaRequest(uint reqId) public{
        require(arendaRequests[reqId].owner == msg.sender, "Flat isnt yours");
        require(arendaRequests[reqId].arendaStatus == true, "Ad is not active");
        if (arendaRequests[reqId].status == true){
            require(arendaRequests[reqId].startArenda + arendaRequests[reqId].term < block.timestamp);

        }
        arendaRequests[reqId].arendaStatus = false;
    }


    //Функция проверки, не закончился ли срок аренды у арендатора, если закончился квартиру можно снять снова


    function bookFlat(uint reqId) public payable{
        require(FlatSell.flats[arendaRequests[reqId].owner][arendaRequests[reqId].flatId].own == true, "This flat has been sold");
        require(arendaRequests[reqId].owner != msg.sender, "You cant rent your own flat");
        require(arendaRequests[reqId].arendaStatus == true, "Ad is not active");
        require(arendaRequests[reqId].status == false, "Flat already booked by someone");
        require(msg.value == arendaRequests[reqId].price, "You dont have enough money");

        arendaRequests[reqId].renter = msg.sender;
    }

    function cancelBook(uint reqId) public{
        require(arendaRequests[reqId].status == false, "Flat already booked");
        require(arendaRequests[reqId].renter == msg.sender, "You didn't book this");

        payable(msg.sender).transfer(arendaRequests[reqId].price);
        arendaRequests[reqId].renter = address(0);
    }

    function bookFlatAccept(uint reqId) public{
        require(FlatSell.flats[arendaRequests[reqId].owner][arendaRequests[reqId].flatId].own == true, "This flat has been sold");
        require(arendaRequests[reqId].owner == msg.sender, "Flat isnt yours");
        require(arendaRequests[reqId].arendaStatus == true, "Ad is not active");

        arendaRequests[reqId].status = true;
        payable(msg.sender).transfer(arendaRequests[reqId].price);
    }

    function bookFlatReject(uint reqId) public{
        require(arendaRequests[reqId].owner == msg.sender, "Flat isnt yours");
        require(arendaRequests[reqId].arendaStatus == true, "Ad is not active");
        require(arendaRequests[reqId].status == false, "Flat is already for rent.");

        payable(arendaRequests[reqId].renter).transfer(arendaRequests[reqId].price);
        arendaRequests[reqId].renter = address(0);
    }

    function showAllArendaRequests() public view returns (flatArendaRequest[] memory){
        return arendaRequests;
    }

    function showFlatInfo(address owner, uint flatId) public view returns (Flat memory){
        return flats[owner][flatId];
    }

}


contract flatGift is FlatSell, FlatArenda{

    struct presentRequest{
        address reciever;
        address flatOwner;
        uint flatId;
        bool answer; // Согласился ли принять подарок получатель
        bool status; // активен ли запрос
    } 
    
    presentRequest[] presentRequests;

    function presentFlat(uint flatId, address reciever) public{
        require(FlatSell.flats[msg.sender].length > flatId, "Flat doesn't exist");
        require(FlatSell.flats[msg.sender][flatId].own == true, "This flat has been sold");
        require(msg.sender != reciever, "You can't give a gift to yourself");
        
        presentRequests.push(presentRequest(reciever, msg.sender, flatId, false, false));
    }

    function cancelPresent(uint id) public{
        require(presentRequests[id].flatOwner == msg.sender, "This is not your request");
        require(presentRequests[id].status == false, "Request not active");

        presentRequests[id].status = true;
    }

    function answerOnPresent(uint id, bool answer) public payable{
        require(FlatSell.flats[presentRequests[id].flatOwner][presentRequests[id].flatId].own == true, "This flat has been sold");
        require(presentRequests[id].status == false, "Request not active");
        require(msg.sender == presentRequests[id].reciever, "Its not your request");

        presentRequests[id].status = true;
        presentRequests[id].answer = answer;

        if (answer == true){
            FlatSell.flats[presentRequests[id].flatOwner][presentRequests[id].flatId].own = false;
            uint square = flats[presentRequests[id].flatOwner][presentRequests[id].flatId].square;
            uint term = flats[presentRequests[id].flatOwner][presentRequests[id].flatId].term;
            FlatSell.flats[presentRequests[id].reciever].push(Flat(square, term, true));
        }
    }
}